// Use only for debugging!
#include "NaiveForest.h"

#include <sstream>
#include <iostream>
#include <stdexcept>
#include <fstream>
#include <vector>
#include <string>
#include <utility>
#include <ctime>
#include <cstring>
#include <cassert>
#include <getopt.h>

using namespace std;

/**
 * Flags set based on command line parameters
 */
bool verbose = false;
bool debug = false;


NaiveForest *nf = 0;

/** 
 * Search throug given (sub)tree and return the number of occurrences
 *
 * Note: This is slow for any reasonable sized input.
 */
unsigned search(NaiveForest::node_p node, string const &pat, unsigned d)
{
    if (debug)
    {
        for (unsigned i = 0; i < d; ++i)
            cout << " ";
        cout << nf->getC(node) << endl;
    }
    
    if (d == pat.size())
        return 1;

    unsigned occs = 0;

    if (!nf->isLeaf(node))
    {
        // Process children with symbol pat[d]
        NaiveForest::node_p child = nf->getChild(node);
        while (child)
        {
            if (nf->getC(child) == pat[d])
                occs += search(child, pat, d+1);

            child = nf->getSibling(child);
        }
        assert(child == 0);
    }

    return occs;
}

vector<unsigned> search(string const &pat)
{
    NaiveForest::node_p node = 0;
    vector<unsigned> result(nf->numberOfTrees());

    for (ulong j = 0; j < nf->numberOfTrees(); ++j, ++node)
    {
        if (debug)
            cout << "----------------------------------------------------------------------------" << endl
                 << "Searching tree number " << j << endl;

        while (!nf->isRoot(node))
            ++node;
        
        unsigned occs = 0;
        if (nf->getC(node) == pat[0])
            occs = search(node, pat, 1);

        result[nf->getEntry(node)] += occs;
    }
    return result;
}

void input_size(istream *input, unsigned &entries, ulong &trees, ulong &nodes)
{
    entries = 0;
    trees = 0;
    nodes = 0;
    string row;
    while (getline(*input, row).good()) 
    {
        if (row[0] == '>')
            ++entries;
        else
        {
            ++trees;
            if (row.size() % 3 != 0)
            {
                cerr << "error: invalid input row length at row:" << endl
                     << row << endl;
                abort();
            }
            nodes += row.size()/3;
        }
    }
}

void parse_entries(istream *input, NaiveForest *nf, ulong estimatedLength, time_t wctime)
{
    unsigned entry = 0;
    ulong j = 0;
    string row;
    string name = "undef";
    while (getline(*input, row).good()) 
    {
        j += row.size();

        if (row[0] == '>')
        {
            name = row.substr(1);
            ++entry;
            if (verbose && entry % 1000 == 0 )
            {
                cerr << "Inserting entry n:o " << entry << ", name: " << name << " (";
                if (estimatedLength)
                    cerr << (100*j/estimatedLength) << "%, ";
                cerr << "elapsed " << std::difftime(time(NULL), wctime) << " s, " 
                     << std::difftime(time(NULL), wctime) / 3600 << " hours)" << endl;
            }
        }
        else
            nf->add(row, entry-1);
    }
    row.clear();
}

unsigned str2unsigned(string const &str) 
{
    stringstream ss(str);
    unsigned n;
    ss >> n;
    return n;
}

vector<string> splitFreqs(string const &str) 
{
    // Separator is ' '
    stringstream ss(str);
    vector<string> tokens;
    while (ss.good ()) 
    {
        string token;
        ss >> token;
        tokens.push_back(token);
    }
    return tokens;
}

pair<unsigned,unsigned> splitFreq(string const &str)
{
    // Separator is ':'
    size_t i = str.find(':');
    if (i == string::npos)
    {
        cerr << "error: unable to tokenize the string \"" << str << "\"" << endl;
        abort();
    }

    unsigned d = str2unsigned(str.substr(0, i));
    unsigned o = str2unsigned(str.substr(i + 1));
    return make_pair(d,o);
}

void print_usage(char const *name)
{
    cerr << "usage: " << name << " [options] <fasta> <result>" << endl
         << "Check README or `" << name << " --help' for more information." << endl;
}

void print_help(char const *name)
{
    cerr << "usage: " << name << " [options] <fasta> <result>" << endl << endl
         << "Give two filenames as input. "
         << "The first file must be in FASTA format." << endl
         << "The second file (or '-' for stdin) must be a result file generated by 'traverse'." << endl
         << "The result is compared against the original tree to check validity." << endl
         << "This will be slow for any resonalbe sized input." << endl << endl
         << "Options:" << endl
         << " -h, --help                    Display command line options." << endl
         << " -v, --verbose                 Print progress information." << endl;
}

int main(int argc, char **argv) 
{
    /**
     * Parse command line parameters
     */
    if (argc == 1)
    {
        print_usage(argv[0]);
        return 1;        
    }

    static struct option long_options[] =
        {
            {"help",        no_argument,       0, 'h'},
            {"verbose",     no_argument,       0, 'v'},
            {0, 0, 0, 0}
        };
    int option_index = 0;
    int c;
    while ((c = getopt_long(argc, argv, "hv",
                            long_options, &option_index)) != -1) 
    {
        switch(c) 
        {
        case 'h':
            print_help(argv[0]);
            return 0;
        case 'v':
            verbose = true; break;
        case '?':
            print_usage(argv[0]);
            return 1;
        default:
            print_usage(argv[0]);
            std::abort();
        }
    }

    if (argc - optind < 2)
    {
        cerr << argv[0] << ": expecting two input files!" << endl;
        print_usage(argv[0]);
        return 1;
    }
        
    if (argc - optind > 2)
        cerr << "Warning: too many filenames given! Ignoring all but first two." << endl;

    string inputfile = string(argv[optind++]);
    string resultfile = string(argv[optind++]);

    istream *fp;
    /*if (inputfile == "-") 
        fp = &std::cin; // Not supported here!
    else*/
    fp = new std::ifstream(inputfile.c_str());

    if (!fp->good())
    {
        cerr << argv[0] << ": unable to read input file " << inputfile << endl;
        exit(1); 
    }

    cerr << std::fixed;
    cerr.precision(2);
    time_t wctime = time(NULL);

    // estimate the total input sequence length
    fp->seekg(0, ios::end);
    long estLength = fp->tellg();
    if (estLength == -1)
    {
        cerr << "error: unable to seek input file" << endl;
        estLength = 0;
    }
    fp->seekg(0);
    if (verbose)
        cerr << "Input file size is " << estLength/1024 << " kb." << endl;

    /**
     * Count the input sizes
     */
    unsigned entries = 0;
    ulong trees = 0, nodes = 0;
    input_size(fp, entries, trees, nodes);
    fp->clear(); // forget previous EOF
    fp->seekg(0);

    if (verbose)
        cerr << "Number of FASTA entries: " << entries << endl 
             << "Total number of trees: " << trees << endl
             << "Total number of nodes: " << nodes << endl
             << "Parsing the input..." << endl;
    
    /**
     * Parse all trees
     */
    nf = new NaiveForest(entries, trees, nodes);
    parse_entries(fp, nf, estLength, wctime);
    if (debug)
        nf->debugPrint();

    ulong t = nf->numberOfNodes();
    if (verbose)
        cerr << "Number of nodes: " << t << endl
             << "Number of leaves: " << nf->numberOfLeaves() << endl
             << "Tree height: " << nf->getHeight() << endl; 

    if (fp != &std::cin)
        delete fp;
    fp = 0;

    /**
     * Checking...
     */
    if (resultfile == "-") 
        fp = &std::cin;
    else
        fp = new std::ifstream(resultfile.c_str());

    if (!fp->good())
    {
        cerr << argv[0] << ": unable to read result file " << resultfile << endl;
        exit(1); 
    }
    if (verbose) cerr << "------------------------------------------------------------------------" << endl 
                      << "Checking results..." << endl;


    ulong j = 0;
    string row;
    string pattern = "undef";
    while (getline(*fp, row).good()) 
    {
        if (verbose && j && j % 1000 == 0)
            cerr << j << " results checked... OK" << endl;
            
        // Parse row
        pattern = row.substr(0, row.find(' '));
        string occs = row.substr(row.find(' ') + 1);
        if (debug) cerr << "pattern = " << pattern << ", occs = " << occs << "," << endl;
        vector<unsigned> freq(nf->numberOfTrees());
        vector<string> tokens = splitFreqs(occs);
        for (vector<string>::iterator it = tokens.begin(); it != tokens.end(); ++it)
        {
            pair<unsigned,unsigned> token = splitFreq(*it);
            freq[token.first] = token.second;
        }
            
/*        for (unsigned i = 0; i <nf->numberOfTrees(); ++i)
            if (freq[i])
                cerr << "freq[" << i << "] = " << freq[i] << endl;
*/

        vector<unsigned> result = search(pattern);
        for (unsigned i = 0; i <nf->numberOfTrees(); ++i)
            if (freq[i] != result[i])
            {
                cerr << "freq[" << i << "] = " << freq[i] << " but result[" << i << "] = " << result[i] << endl;
                abort();
            }


        ++j;
    }

    /**
     * Clean up
     */
    delete nf;
    nf = 0;
    
    if (fp != &std::cin)
        delete fp;
    fp = 0;

    std::cerr << "Test complete. "
              << "(total wall-clock time " << std::difftime(time(NULL), wctime) << " s, " 
              << std::difftime(time(NULL), wctime) / 3600 << " hours)" << endl;
    return 0;
}
 
